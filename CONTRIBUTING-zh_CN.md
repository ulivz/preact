# 贡献

此文档适用于对 Preact 做出贡献的开发者，以及记录我们的内部流程，例如发布新版本。

## 入门

此步骤将帮助您设置开发环境。包括我们用于构建 Preact 和开发者工具（如 git 提交钩子）的所有依赖项。

1. 克隆 git 仓库：`git clone git@github.com:preactjs/preact.git`
2. 进入克隆后的文件夹：`cd preact/`
3. 安装所有依赖项：`npm install`

## 仓库结构

此仓库包含 Preact 本身以及诸如调试包之类的附加组件。这反映在此存储库的目录结构中。每个软件包都有一个 `src/` 文件夹，可以在其中找到源代码，一个 `test` 文件夹用于检查 `src/` 中的代码是否正确的各种测试，以及一个 `dist/` 文件夹，可以在其中找到打包好的构建产物。注意，`dist/` 文件夹初始可能不会出现。一旦运行 `package.json` 中的任何构建脚本，它将被创建。稍后会介绍更多相关内容;)

快速了解我们的仓库：

```bash
# 仓库根目录（克隆仓库时使用的文件夹）
/
  src/  # 核心源代码
  test/ # 核心单元测试
  dist/ # 用于在 npm 上发布的构建产物（可能不存在）

  # 子包，可以通过 `preact/compat` 导入。
  # Compat 表示尽可能接近 react API 的兼容性层（主要是旧版API）
  compat/
  	src/  # compat 插件的源代码
  	test/ # 与 compat 插件相关的测试
  	dist/ # 用于在 npm 上发布的构建产物（可能不存在）

  # 子包，可以通过 `preact/hooks` 导入。
  # hooks API 是基于 effect 的 API，用于处理组件生命周期。
  # 它与 React 中的 hooks 类似
  hooks/
  	src/  # hooks 插件的源代码
  	test/ # 与 hooks 插件相关的测试
  	dist/ # 用于在 npm 上发布的构建产物（可能不存在）

  # 子包，可以通过 `preact/debug` 导入。
  # 包括针对 Preact 应用中常见错误的调试警告和错误消息。还托管了开发者工具桥
  debug/
  	src/  # debug 插件的源代码
  	test/ # 与 debug 插件相关的测试
  	dist/ # 用于在 npm 上发布的构建产物（可能不存在）

  # 子包，可以通过 `preact/test-utils` 导入。
  # 提供辅助功能，使测试 Preact 应用程序更容易
  test-utils/
  	src/  # test-utils 插件的源代码
  	test/ # 与 test-utils 插件相关的测试
  	dist/ # 用于在 npm 上发布的构建产物（可能不存在）

  # 一个演示应用程序，我们用它来调试棘手的错误和尝试新功能。
  demo/

  # 包含构建脚本和开发依赖项
  package.json
```

_注意：在另一个 repo 中有用于在服务器上渲染 Preact 的代码，这是一个完全独立的 npm 软件包。可以在这里找到：[https://github.com/preactjs/preact-render-to-string](https://github.com/preactjs/preact-render-to-string)_

### `mangle.json` 的作用是什么？

这是一个特殊的文件，可以用来指定 `terser`（以前称为 `uglify`）如何压缩变量名。因为每个子包都有自己的分发文件，所以我们需要确保打包之间的变量名保持一致。

## `options.js` 的作用是什么？

Preact 的特点是我们支持多种方式将其嵌入到我们的渲染器中。我们的所有插件都使用它来在渲染过程的不同阶段注入代码。它们记录在我们的类型定义 `internal.d.ts` 中。核心本身并不使用它们，这就是为什么该文件只包含一个空的 `object`。

## 重要分支

我们将每个 PR 合并到 `main` 分支，这是我们用来发布 npm 代码的分支。对于之前的 Preact 发行版本线，我们有一个名为 `8` 的分支处于维护模式。作为新贡献者，您不需要处理这些;)

## 创建您的第一个 Pull Request

我们尽量让贡献 Preact 变得简单，充分利用 GitHub 的“草稿 PR”功能，将 Pull Request（简称 = PR）标记为进行中的工作。当开发人员认为某种想法值得加入 Preact 并编写了一些粗略的代码时，PR 往往会被发布。PR 不需要完美或真正完成；)

创建 PR 或草稿 PR 后，我们的社区通常会参与关于所提议更改的讨论。有时这包括针对测试用例的想法，甚至是实现功能的不同方法。通常还包括如何缩小代码的想法。我们通常将后者称为 “代码高尔夫” 或 “高尔夫”。

当一切准备就绪时，有人会批准 PR，并将更改合并到 `main` 分支，我们通常在几天/一周后剪切发布版。

_这里的重点是，我们将在整个过程中指导您。我们在这里帮助您，让 PR 准备好批准!_

简要总结：

1. 进行更改并提交 PR
2. 根据反馈修改更改（如果有）
3. PR 将合并到 `main`
4. 会剪切新版本（每 2-3 周发布一次）。

## 常用脚本的贡献

可以通过 `npm run [script]` 或 `yarn [script]` 分别执行脚本。

- `build` - 编译所有包，以便发布到 npm
- `build:core` - 只构建 Preact 本身
- `build:debug` - 仅构建调试插件
- `build:hooks` - 仅构建钩子插件
- `build:test-utils` - 仅构建测试工具插件
- `test:ts` - 运行 TypeScript 定义的所有测试
- `test:karma` - 运行所有单元/集成测试。
- `test:karma:watch` - 与上面相同，但是如果检测到代码更改，它将自动重新运行测试套件。

但说实话，我们自己只使用 `build` 和 `test:karma:watch`。其他的主要用在我们的 CI 流水线上，我们很少使用它们。

_注意：`test:karma` 和 `test:karma:watch` 都监听环境变量 `COVERAGE=true`。禁用代码覆盖率可以显著加快完成测试套件所需的时间。_

_注意 2：测试套件基于 `karma` 和 `mocha`。可以通过附加 `.only` 执行单个测试：_

```jsx
it.only('should test something', () => {
	expect(1).to.equal(1);
});
```

## 常见术语和变量名

- `vnode` -> 是 `virtual-node` 的简写，表示一个对象，用于描述组件或 DOM 节点的外观
- `commit` -> “提交”是将所有更改刷新到 DOM 的时刻
- `c` -> 在整个代码库中，变量 `c` 始终指代一个 `component` 实例。
- `diff/diffing` -> Diffing 描述了比较两个“事物”的过程。在我们的示例中，我们比较之前的 `vnode` 树与新的树，并将差异应用到 DOM 上。
- `root` -> `vnode` 树的最顶层节点

## 了解代码库的技巧

- 查阅函数定义正上方的 JSDoc 块，以了解其功能。它包含每个函数参数的简短描述以及它的作用。
- 检查函数的调用位置以了解其用法。现代编辑器/IDE 允许您快速找到这些位置，或者使用原始的搜索功能。

## 常见问题解答

### 为什么 JSDoc 使用 TypeScript 语法来指定类型？

团队中的几位成员非常喜欢 TypeScript，我们希望充分利用它的优势，例如改进自动补全功能，为 Preact 提供支持。我们甚至尝试过将 Preact 移植到 TypeScript，但遇到了许多与 DOM 类型相关的问题。这些问题会迫使我们在代码库中填充许多 `any` 类型转换，使我们的代码非常嘈杂。

幸运的是，TypeScript 有一种模式，可以通过重用 JSDoc 块中定义的类型来对 JavaScript 代码进行比较可靠的类型检查。虽然不是完美的，而且当离函数参数越远时，类型推断往往会出现问题，但它足够强大，可以帮助我们完成自动补全功能。另一个优点是我们可以确保我们的 TypeScript 定义文件同时是正确的。

有关更多信息，请查看 [官方 TypeScript 文档](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)。

_请注意，我们有单独的测试用于 TypeScript 定义文件。我们只使用 `ts-check` 进行本地开发，不在 CI 等其他地方进行检查。_

### 为什么代码库经常使用 `let` 而不是 `const`？

除了历史原因外，没有真正的理由。在 prettier 的自动格式化和压缩器不像今天这样先进之前，我们使用了相当简练的代码风格。代码风格故意旨在使代码看起来尽可能简洁、短小。由于 `let` 关键字比 `const` 略短，所以我们只使用了 `let`。这仅出于样式原因。

这有助于我们保持关注体积的目光，但使新手开始为 Preact 做贡献变得困难。基于这个原因，我们转向使用 `prettier` 并放宽了关于使用 `let` 或 `const` 的规定。现在我们两者都用，但你仍然可以在许多现有的地方找到 `let` 的用法。

最后，无论是使用 `const`、`let` 还是两者混合，对大小都没有影响。我们的代码会被降级为 npm 上的 `ES5`，所以两者都会被替换为 `var`。因此，在我们的代码库中使用哪一个并不重要。

只有当在 npm 上发布现代 JavaScript 代码成为主流且打包器效仿时，这才会变得重要。

## 如何创建一个好的错误报告

为了能够解决问题，我们需要在我们的机器上看到它们。只有当我们可以复现错误时，这才有可能。最简单的方法就是将问题缩小到特定组件或它们的组合。可以通过尽可能删除与之无关的代码来实现。

最好的方法是制作一个 [codesandbox](https://codesandbox.io/)。这样你可以轻松共享有问题的代码，并确保其他人可以看到你看到的相同问题。

对我们来说，[codesandbox](https://codesandbox.io/) 比 1000 个词更有意义:tada:

## 我有关于如何为 Preact 做贡献的更多问题。我该如何联系您？

我们密切关注我们的问题，并拥有一个非常活跃的 [Slack 工作区](https://chat.preactjs.com/)。几乎所有的沟通都通过这两种沟通形式进行。

## 发布 Preact（仅限维护者）

本指南适用于具有发布新版本到 npm 所需权限的核心团队成员。

1. 创建一个 PR，在其中**仅**增加 `package.json` 和其他地方的版本号。简单的查找和替换就可以实现。（注意：我们遵循 `SemVer` 规范）
2. 等待 PR 获得批准并合并。
3. 切换回 `main` 分支并拉取已合并的 PR
4. 为要发布的新版本创建并推送标签：
   1. `git tag 10.0.0`
   2. `git push --tags`
5. 等待发布工作流完成
   - 它将创建一个草稿发布，并将构建好的 npm 包作为资产上传到发布中
6. 在 GitHub 中填写发布说明并发布
7. 使用创建的标签运行发布脚本
   1. `node ./scripts/release/publish.mjs 10.0.0`
   2. 确保在 npm 中启用了 2FA，否则上述命令将失败。
   3. 如果您正在进行预发布，请将 `--npm-tag next` 添加到 `publish.mjs` 命令中以在不同的标签下发布（默认为 `latest`）
8. 发推文

## 旧版发布（8.x）

> **注意：** 当从 10.x 分支切换时，确保正确清理项目。

0. 运行 `rm -rf dist node_modules && npm i` 以确保具有正确的依赖项。
1. [编写发布说明](#编写发布说明)，并将其作为 GitHub 中的草稿保存
   1. 我建议在离线编辑器中编写它们，因为在 GitHub 上编辑草稿每次都会更改 URL。
2. 创建一个 PR，在其中**仅**增加 `package.json` 的版本号（注意：我们遵循 `SemVer` 规范）
3. 等待 PR 获得批准并合并。
4. 切换回 `main` 分支并拉取已合并的 PR
5. 运行 `npm run build && npm publish`
   1. 确保在 npm 中启用了 2FA，否则上述命令将失败。
   2. 如果您正在进行预发布，请将 `--tag next` 添加到 `npm publish` 命令中以在不同的标签下发布（默认为 `latest`）
6. 发布发布说明并创建正确的 git 标签。
7. 发推文

## 编写发布说明

发布说明已成为关于 Preact 世界发生情况的小型博客文章。标题通常采用以下格式：

```txt
版本名称
```

示例：

```txt
10.0.0-beta.1 Los Compresseros
```

名称是可选的，我们只是喜欢找到富有创意的名字:wink:

为了使它们更有趣，我们尽量简洁，只反映当前情况。在撰写时，我们遵循以下一些规则：

- 保持友好，使用积极的语气。避免负面词汇
- 展示，而不仅仅是讲述。
- 诚实。
- 不要写得太多，保持简单和简短。
- 避免做出承诺和过度承诺。这会导致用户不满意
- 尽可能避免与其他框架进行比较
- 突出展示优秀的社区贡献（或伟大的问题报告）
- 如有疑问，赞美用户。

在此部分之后，我们通常接着一个按用户重要性顺序划分的变更日志部分，包括四个组：

- 功能
- 错误修复
- 类型定义
- 维护

我们通过这个方便的命令行程序生成它：[changelogged](https://github.com/marvinhagemeister/changelogged)。它会收集并格式化两个标签之间已合并的所有 PR 的描述。通常的命令是 `changelogged 10.0.0-rc.2..HEAD`，类似于如何使用 git 比较两个时间点的差异。这将使你完成 90% 的工作，但你仍然需要将其划分为组。统一描述的格式也是一个好主意，这样它们就更容易阅读，看起来不那么凌乱。
